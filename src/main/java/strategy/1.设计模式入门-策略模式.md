# 学习参考：

[《Head First 设计模式》第一章 设计模式入门](https://learning.oreilly.com/library/view/head-first-design/0596007124/ch01.html)

[极客时间《设计模式之美》策略模式相关内容](https://time.geekbang.org/column/article/214014)



# HeadFirst SimUDuck

## 需求描述：

duck 鸭子的对象类

quack() 叫声、swinm() 游泳、display() 外观、fly() 是否会飞

等等不同行为，然而有些行为是不所有鸭子都具备的。比如玩具鸭就不能飞。

## **实现方式：**

代码目录如下

``` java
└───simuduck
    ├───composition	// 组合
    ├───extend		// 继承
    └───iface		// 接口
```



### 继承

为了满足代码复用使用继承，把鸭子的行为放在超类中，子类继承实现。然而等后面不同行为的鸭子越来越多，缺点就暴露出来了。

##### **继承缺点：**

1、代码在多个子类重复。某些子类不需要的行为，还是要显示覆盖，造成不必要的重复。

2、运行时的行为不容易改变。

3、很难知道所有鸭子的全部行为。都是继承父类，有些子类显示覆盖的行为无法直观了解，所以很难直到所以鸭子实际的行为。

4、改变会牵一发动全身，造成其他鸭子不想要的改变。


### 接口

单纯使用接口也有弊端，相同实现代码无法复用。

### 组合

**设计原则：**找出应用中可能需要变化之处，把它们独立出来，不要和那些需要变化的代码混在一起。

把会变化的部分取出并封装起来，方便以后扩展时不会影响其他不需要改变的部分。（把duck类中会变的和不变的方法分开）



**设计原则：**针对接口编程（针对超类型编程），而不是实现编程。

（鸭子的行为单独为一类，提供行为接口的实现）



**设计原则：**多用组合，少用继承。

将行为类结合起来使用就叫组合，duck 类引入行为类的声明变量。



**封装-动态设定行为**

新建set方法，动态设置行为变量。



**策略模式**

将上面封装中的行为->改叫为算法，可以动态设置不同的算法。

**正式定义：**策略模式定义了算法族，分别封装起来，让他们直接可以互相替换，此模式让算法的变化独立于使用算法的客户端。

客户端、算法变化互不相影响，互相组合使用的。