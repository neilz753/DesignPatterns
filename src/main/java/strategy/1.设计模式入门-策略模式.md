# 学习参考：

[《Head First 设计模式》第一章 设计模式入门](https://learning.oreilly.com/library/view/head-first-design/0596007124/ch01.html)

[极客时间《设计模式之美》策略模式(上)](https://time.geekbang.org/column/article/214014)

[极客时间《设计模式之美》策略模式(下)](https://time.geekbang.org/column/article/215132)



# HeadFirst SimUDuck

## 需求描述：

duck 鸭子的对象类

quack() 叫声、swinm() 游泳、display() 外观、fly() 是否会飞

等等不同行为，然而有些行为是不所有鸭子都具备的。比如玩具鸭就不能飞。

## 实现方式：

代码目录如下

``` java
└───simuduck
    ├───composition	// 组合
    ├───extend		// 继承
    └───iface		// 接口
```

### 继承

为了满足代码复用使用继承，把鸭子的行为放在超类中，子类继承实现。然而等后面不同行为的鸭子越来越多，缺点就暴露出来了。

##### **继承缺点：**

1、代码在多个子类重复。某些子类不需要的行为，还是要显示覆盖，造成不必要的重复。

2、运行时的行为不容易改变。

3、很难知道所有鸭子的全部行为。都是继承父类，有些子类显示覆盖的行为无法直观了解，所以很难直到所以鸭子实际的行为。

4、改变会牵一发动全身，造成其他鸭子不想要的改变。


### 接口

单纯使用接口也有弊端，相同实现代码无法复用。

### 组合

**设计原则：** 找出应用中可能需要变化之处，把它们独立出来，不要和那些需要变化的代码混在一起。

把会变化的部分取出并封装起来，方便以后扩展时不会影响其他不需要改变的部分。（把duck类中会变的和不变的方法分开）

**设计原则：** 针对接口编程（针对超类型编程），而不是实现编程。

（鸭子的行为单独为一类，提供行为接口的实现）

**设计原则：** 多用组合，少用继承。

将行为类结合起来使用就叫组合，duck 类引入行为类的声明变量。

**封装-动态设定行为**

新建set方法，动态设置行为变量。



## 引出策略模式

将上面封装中的行为->改叫为算法，可以动态设置不同的算法。

**策略模式定义：**

```
Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.
```

定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。



# 《设计模式之美》策略模式（上）

```
├───ifelse		// 策略接口、使用
│   ├───algo	// 具体策略
│   └───factory	// 策略工厂
```



策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。

- 策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。

- 策略的创建由工厂类来完成，封装策略创建的细节。

- 策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。

除此之外，我们还可以通过策略模式来移除 if-else 分支判断。实际上，这得益于策略工厂类，更本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。