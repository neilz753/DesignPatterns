

# 应用场景

一提到策略模式，有人就觉得，它的作用是避免 if-else 分支判断逻辑。实际上，这种认识是很片面的。

策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。

除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。



# 原理解读

**策略模式定义：**

> Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.


定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。

**设计原则和思想其实比设计模式更加普适和重要，掌握了代码的设计原则和思想，我们甚至可以自己创造出来新的设计模式。**



# 代码实现

策略模式用来解耦策略的**定义、创建、使用**。实际上，一个完整的策略模式就是由这三个部分组成的。

- 策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。

- 策略的创建由工厂类来完成，封装策略创建的细节。

- 策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：**编译时静态确定**和**运行时动态确定**。其中，“运行时动态确定”才是策略模式最典型的应用场景。

## 相关demo目录：

```java
├───src
│   ├───main
│   │   ├───java
│   │   │   └───strategy	// 策略模式相关demo
│   │   │       ├───filesort	// 文件排序
│   │   │       ├───ifelse		// if-else or switch分支判断
│   │   │       └───simuduck	// SimUDuck
```



### SimUDuck

#### 需求描述：

duck 鸭子的对象类

quack() 叫声、swinm() 游泳、display() 外观、fly() 是否会飞

等等不同行为，然而有些行为是不所有鸭子都具备的。比如玩具鸭就不能飞。

#### 实现方式：

代码目录如下

``` java
└───simuduck
    ├───composition	// 组合
    ├───extend		// 继承
    └───iface		// 接口
```



#### 继承

为了满足代码复用使用继承，把鸭子的行为放在超类中，子类继承实现。然而等后面不同行为的鸭子越来越多，缺点就暴露出来了。

##### **继承缺点：**

1、代码在多个子类重复。某些子类不需要的行为，还是要显示覆盖，造成不必要的重复。

2、运行时的行为不容易改变。

3、很难知道所有鸭子的全部行为。都是继承父类，有些子类显示覆盖的行为无法直观了解，所以很难直到所以鸭子实际的行为。

4、改变会牵一发动全身，造成其他鸭子不想要的改变。




#### 接口

单纯使用接口也有弊端，相同实现代码无法复用。



#### 组合

**设计原则：** 找出应用中可能需要变化之处，把它们独立出来，不要和那些需要变化的代码混在一起。

把会变化的部分取出并封装起来，方便以后扩展时不会影响其他不需要改变的部分。（把duck类中会变的和不变的方法分开）

**设计原则：** 针对接口编程（针对超类型编程），而不是实现编程。

（鸭子的行为单独为一类，提供行为接口的实现）

**设计原则：** 多用组合，少用继承。

将行为类结合起来使用就叫组合，duck 类引入行为类的声明变量。

**封装-动态设定行为**

新建set方法，动态设置行为变量。



#### 引出策略模式

将上面封装中的行为->改叫为算法，可以动态设置不同的算法。



### If-else

```
├───ifelse		// 策略接口、使用
│   ├───algo	// 具体策略
│   └───factory	// 策略工厂
```

通过策略模式来移除 if-else 分支判断。实际上，这得益于策略工厂类，更本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。



### File Sort

结合“给文件排序”这样一个具体的例子，来详细讲一讲策略模式的设计意图和应用场景。

#### 需求描述：

实现对一个文件进行排序的程序。文件中只包含整型数，相邻的数字通过逗号来区隔。

文件大小的不同，排序处理需要的算法也不同，快排、外部排序、MapReduce等。

##### 开闭原则

> 在面向对象编程领域中，开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。

上面的文件排序例子，当我们添加新的排序算法的时候，还是需要修改代码，并不完全符合开闭原则。

对于 Java 语言来说，我们可以通过反射来避免对策略工厂类的修改。

具体是这么做的：

- 我们通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；
- 策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；
- 当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。

对于 Sorter 来说，我们可以通过同样的方法来避免修改。我们通过将文件大小区间和算法之间的对应关系放到配置文件中。当添加新的排序算法时，我们只需要改动配置文件即可，不需要改动代码。

##### KISS 原则

> KISS 原则是用户体验的高层境界，简单地理解这句话，就是要把一个产品做得连白痴都会用，因而也被称为“懒人原则”。换句话说来，“简单就是美”。

一提到 if-else 分支判断，有人就觉得它是烂代码。如果 if-else 分支判断不复杂、代码不多，这并没有任何问题，毕竟 if-else 分支判断几乎是所有编程语言都会提供的语法，存在即有理由。遵循 KISS 原则，怎么简单怎么来，就是最好的设计。非得用策略模式，搞出 n 多类，反倒是一种过度设计。
