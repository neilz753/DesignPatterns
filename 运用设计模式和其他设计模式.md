- 让设计模式自然而然的出现在你的设计中，而不是为了使用而使用。
- 设计模式并非僵化的教条；可以根据自己的需要采用或调整。
- 总是使用满足需求的最简单解决方案，不管它用不用到设计模式。
- 学习设计模式，可以帮助自己熟悉这些模式以及它们之间的关系。
- 模式的分类（将模式分成不同种类）不强求，有用就分。
- 牢记：所遇到的大多数模式都是现有模式的变体，而非新的模式。



装饰者。包装一个对象，以提供新的行为。

状态。封装了基于状态的行为，并使用委托在行为之前切换。

迭代器。在对象的集合中游走，而不暴露集合的实现。

外观。简化一群类的接口。

策略。封装可以互换的行为，并使用委托来决定要使用哪一个。

代理。包装对象，以控制对此对象的访问。

工厂方法。由子类决定要创建的具体类是哪一个。

适配器。封装对象，并提供不同的接口。

观察者。让对象能够在状态改变时被通知。

模板方法。由子类决定如何实现一个算法中的步骤。

组合。客户用一致的方式处理对象集合和单个集合。

单例。确保只有一个对象被创造。

抽象工厂。允许客户创建对象的家族，而无需指定他们的具体类。

命令。封装请求成为对象。



# 其他设计模式

## 桥接模式

不止改变你的实现，也改变你的抽象。

## 生成器模式

封装一个产品的构造过程，并允许按步骤构造。

## 责任链模式

让一个以上的对象，有机会能够处理某个请求。

## 蝇量模式

让某个类的一个实例能用来提供许多“虚拟实例”。

## 解释器模式

为语言创建解释器。

解释器模式需要一些形式语法的知识。使用解释器模式定义语法类，每个语法规则都用一个类代表。

## 中介者模式

集中相关对象之间复杂的沟通和控制方式。

- 每个对象在自己状态改变时，告知中介者。
- 每个对象都会回应中介者的请求。

## 备忘录模式

当需要让对象返回之前的状态时，如用户请求"撤销"，使用备忘录模式。

- 储存系统关键对象的重要状态。

- 维护关键对象的封装。

## 原型模式

创建给定类的实例的过程很昂贵或很复杂时，使用原型模式。模式重点在于，在不知道实例化何种特定类的情况下，可以制造出新的实例。

## 访问者模式

当想要为一个对象的组合增加新的能力，且不在乎封装，就可以使用访问者模式。

